// Copyright (c) The University of Dundee 2018-2019
// This file is part of the Research Data Management Platform (RDMP).
// RDMP is free software: you can redistribute it and/or modify it under the terms of the GNU General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.
// RDMP is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU General Public License for more details.
// You should have received a copy of the GNU General Public License along with RDMP. If not, see <https://www.gnu.org/licenses/>.

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Rdmp.Core.Generators;

[Generator]
public class AotObjectFactoryGenerator : IIncrementalGenerator
{
    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        // Register a syntax provider that finds classes with the GenerateAotFactory attribute
        var provider = context.SyntaxProvider
            .CreateSyntaxProvider(
                predicate: static (s, _) => IsSyntaxTargetForGeneration(s),
                transform: static (ctx, _) => GetSemanticTargetForGeneration(ctx))
            .Where(static m => m is not null);

        // Combine the results with the compilation
        var compilation = context.CompilationProvider.Combine(provider.Collect());

        // Generate the source code
        context.RegisterSourceOutput(compilation, static (spc, source) => Execute(source.Item1, source.Item2, spc));
    }

    private static bool IsSyntaxTargetForGeneration(SyntaxNode node)
    {
        return node is ClassDeclarationSyntax classDeclaration &&
               classDeclaration.AttributeLists.Count > 0;
    }

    private static ClassDeclarationSyntax? GetSemanticTargetForGeneration(GeneratorSyntaxContext context)
    {
        var classDeclaration = (ClassDeclarationSyntax)context.Node;

        // Check if the class has the GenerateAotFactory attribute
        foreach (var attributeList in classDeclaration.AttributeLists)
        {
            foreach (var attribute in attributeList.Attributes)
            {
                var attributeSymbol = context.SemanticModel.GetSymbolInfo(attribute).Symbol?.ContainingType;
                if (attributeSymbol?.ToDisplayString() == "Rdmp.Core.Attributes.GenerateAotFactoryAttribute")
                {
                    return classDeclaration;
                }
            }
        }

        return null;
    }

    private static void Execute(Compilation compilation, ImmutableArray<ClassDeclarationSyntax> classes, SourceProductionContext context)
    {
        if (classes.IsDefaultOrEmpty)
            return;

        var generatedClasses = new List<string>();

        foreach (var classDeclaration in classes)
        {
            var model = compilation.GetSemanticModel(classDeclaration.SyntaxTree);
            var classSymbol = model.GetDeclaredSymbol(classDeclaration);

            if (classSymbol == null)
                continue;

            var attributeData = classSymbol.GetAttributes()
                .FirstOrDefault(a => a.AttributeClass?.ToDisplayString() == "Rdmp.Core.Attributes.GenerateAotFactoryAttribute");

            if (attributeData == null)
                continue;

            var factoryCode = GenerateFactoryCode(classSymbol, attributeData);
            if (!string.IsNullOrEmpty(factoryCode))
            {
                generatedClasses.Add(factoryCode);
            }
        }

        if (generatedClasses.Count > 0)
        {
            var finalCode = $@"// <auto-generated/>
// This file was generated by the AotObjectFactoryGenerator

using System;
using System.Collections.Generic;
using Rdmp.Core.Repositories.Construction;

namespace Rdmp.Core.Generated.Factories
{{
    /// <summary>
    /// Generated AOT object factories for RDMP types
    /// </summary>
    public static class AotObjectFactories
    {{
        /// <summary>
        /// Registers all generated factories with the AotObjectFactoryRegistry
        /// </summary>
        public static void RegisterAllFactories()
        {{
            {string.Join(Environment.NewLine + "            ", generatedClasses.Select(c => c.Replace("\n", "\n            ")))}
        }}

        /// <summary>
        /// Gets all generated factory types
        /// </summary>
        public static Type[] GetAllFactoryTypes()
        {{
            return new Type[]
            {{
                {string.Join("," + Environment.NewLine + "                ", generatedClasses.Select((_, i) => $"typeof(GeneratedFactory{i})"))}
            }};
        }}
    }}

{string.Join(Environment.NewLine + Environment.NewLine, generatedClasses.Select((c, i) => GenerateFactoryClass(i, c)))}
}}";

            context.AddSource("AotObjectFactories.g.cs", SourceText.From(finalCode, Encoding.UTF8));
        }
    }

    private static string GenerateFactoryClass(int index, string factoryCode)
    {
        return $@"    /// <summary>
    /// Generated AOT factory #{index}
    /// </summary>
    public static class GeneratedFactory{index}
    {{
        {factoryCode.Replace("\n", "\n        ")}
    }}";
    }

    private static string GenerateFactoryCode(INamedTypeSymbol classSymbol, AttributeData attributeData)
    {
        var className = classSymbol.Name;
        var fullClassName = classSymbol.ToDisplayString();
        var namespaceName = classSymbol.ContainingNamespace?.ToDisplayString() ?? "global";

        var constructors = classSymbol.Constructors.Where(c => c.IsPublic || GetIncludeNonPublic(attributeData)).ToList();
        if (!constructors.Any())
            return string.Empty;

        var factoryMethods = new List<string>();
        var registrationCalls = new List<string>();

        foreach (var constructor in constructors)
        {
            var parameters = constructor.Parameters;
            var parameterTypes = parameters.Select(p => p.Type.ToDisplayString()).ToArray();
            var parameterNames = parameters.Select(p => p.Name).ToArray();

            // Generate constructor delegate
            var delegateType = GetDelegateType(parameters.Length);
            var methodName = GetFactoryMethodName(parameters.Length);

            var factoryMethod = GenerateFactoryMethod(
                className, fullClassName, delegateType, parameterTypes, parameterNames, constructor.IsStatic);

            factoryMethods.Add(factoryMethod);

            // Generate registration call
            var registrationCall = GenerateRegistrationCall(
                fullClassName, delegateType, methodName, parameterTypes, constructor);

            registrationCalls.Add(registrationCall);
        }

        return string.Join(Environment.NewLine + Environment.NewLine, factoryMethods) +
               Environment.NewLine + Environment.NewLine +
               string.Join(Environment.NewLine, registrationCalls);
    }

    private static string GenerateFactoryMethod(string className, string fullClassName, string delegateType,
        string[] parameterTypes, string[] parameterNames, bool isStatic)
    {
        var parameters = string.Join(", ", parameterNames.Select((name, i) => $"{parameterTypes[i]} {name}"));
        var args = string.Join(", ", parameterNames);

        var accessibility = isStatic ? "static" : "";

        return $@"/// <summary>
        /// Creates a new instance of {className} with {parameterTypes.Length} parameters
        /// </summary>
        public static {accessibility} {delegateType} Create{className}Factory{parameterTypes.Length}()
        {{
            return ({args}) => new {fullClassName}({args});
        }}";
    }

    private static string GenerateRegistrationCall(string fullClassName, string delegateType,
        string methodName, string[] parameterTypes, IMethodSymbol constructor)
    {
        var factoryTypeName = $"{fullClassName}Factory";
        var registrationMethod = parameterTypes.Length switch
        {
            0 => "RegisterBlankConstructorFactory",
            1 => "RegisterSingleParameterFactory",
            2 => "RegisterDoubleParameterFactory",
            _ => "RegisterVariableParameterFactory"
        };

        var parameterTypeArgs = string.Join(", ", parameterTypes.Select(t => $"typeof({t})"));

        return $@"AotObjectFactoryRegistry.{registrationMethod}(
            typeof({fullClassName}),
            Create{methodName.Split('.').Last()}(),
            {parameterTypeArgs});";
    }

    private static string GetDelegateType(int parameterCount)
    {
        return parameterCount switch
        {
            0 => "AotConstructor",
            1 => "AotConstructor",
            2 => "AotConstructor",
            _ => "AotVariableConstructor"
        };
    }

    private static string GetFactoryMethodName(int parameterCount)
    {
        return $"CreateFactory{parameterCount}";
    }

    private static bool GetIncludeNonPublic(AttributeData attributeData)
    {
        var includeNonPublic = attributeData.NamedArguments
            .FirstOrDefault(a => a.Key == "IncludeNonPublicConstructors").Value;

        return includeNonPublic is bool value && value;
    }
}